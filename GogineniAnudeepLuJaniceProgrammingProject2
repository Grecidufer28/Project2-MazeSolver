	In this project, the proposed solution consisted of using Depth First Search as the main algorithm to create a perfect maze. It works by ensuring that every single node is visited and accounted for while creating the maze. Then, the program uses both Breadth First Search and Depth First Search to find different solutions to the maze. 
	At first the solution did not come clearly, as our first main issue was to find an efficient method to print out the maze in any capacity. It was eventually decided that there was no efficient way to print out the maze and resulted in using a nested for loop for printing the maze. There are many if statements to handle all the cases in printing the maze. There are inner loops to print the different parts of the maze, separated into the nodes and the lines portions. 
	The general BFS and DFS portions of the maze were not the most diffcult portion of the project, as figuring out the smaller parts of the algorithms were the most difficult to execute. Finding neighbors for both algorithms proved to be a brain teaser for a little while, but was relatively straight forward once we decided to implement it without any regard to efficiency. Anything that had to do with the neighbors of the nodes within the graph initially stumped us but only took a little bit of planning and lots of commenting to cover all the cases and corner cases of the maze.
	Often times, there were many smaller cases in many of the functions that we forgot to consider and had to slowly go back and analyze the cases that the functions would go over and either add new constraints (characteristics to constrain the results) or reconsider a new way to produce the results that we needed to see. It was difficult to make sure that the graph was actually being populated and paired up with the correct neighbors initially since the only way to check was to print it out using the maze or implementing a print to check the nodes.
	The main takeaway from this programming project was the intricacy of implementing graphs and the usefulness of graphs in certain applications. Also, working in a group was also another good lesson, as it forced us to coordinate times and delegate tasks appropriately to make good use of our time.